---
layout: post
title: js面试题及答案
tags:
- js
categories: Js
description: js面试题及答案
---

# js面试题及答案

# 字节length
编写一个方法求一个字符串的字节长度
```js
//方法1
function GetBytes(str){
  var len = str.length;
  var bytes = len;
  for(var i = 0;i<len;i++){
    if(str.charCodeAt(i)>255){
      bytes++;
    }
  }
  return bytes;
}
var s ="j你";
console.log(GetBytes(s));  //中文字占2个字节 

//方法2
function getLeng(str){
  if(!arguments.length || !str){
    return null;
  }
  var len = str.length;
  var newlen = 0;
  for(var i=0; i<len; i++){
    if(str.charCodeAt(i)>255){
      newlen+=2;
    }else{
      newlen++;
    }
  }
  return newlen;
}

var s =" ";
console.log(getLeng(s));
```
# 如何控制alert中的换行
```js
alert("hello \n world")
```

# 解释em
```js
document.getElementById("ElementID").style.fontSize="1.5em" 
```
em是个相对单位。

# 按照格式showTime 
xxxx年xx月xx日xx时xx分xx秒动态显示时间 要求不足10的补0 
```js
<div id="demo"></div>
<script type="text/javascript">

	function f(str){
		return str>9? str :"0"+ str
	}

	function getTime(){
		var time = new Date();
		
		var year = time.getFullYear();
		var month = f(time.getMonth()+1);
		var day = f(time.getDate());
		var hour = f(time.getHours());
		var minutes = f(time.getMinutes());
		var second = f(time.getSeconds());

		var mytime = year+ "-" + month + "-" + day + " " + hour +":"+ minutes + ":" +second;
		return mytime;

	}

	function intext(){
		document.getElementById("demo").innerHTML = getTime()
	}
	setInterval(intext,1000);
</script>
```

# 数组unique
编写一个方法 去掉一个数组的重复元素 
```js
var arr = [ 1,2,3,"1"];
	//方法1
	function getArrUnique(arr){
		var newArr = [ ];
		for (var i=0; i < arr.length;i++){

			if(newArr.indexOf(arr[i]) == -1)
				newArr.push(arr[i]);	
		}
		return newArr;
	}
	
	function getArrUnique2(arr){
		var newArr = [];
		var obj ={};
		for(var i=0;i<arr.length;i++){
			if(!obj[arr[i]]){
				obj[arr[i]] = true;
				newArr.push(arr[i]);
			}

		}
		return newArr;  
		
	}
	console.log(getArrUnique2(arr));  //[1,2,3]  error result

	//改进以上方法
	//方法2
	function getArrUnique3(arr){
		var newArr = [];
		var obj ={};
		for(var i=0;i<arr.length;i++){
			if(!obj[ typeof (arr[i]) + arr[i] ]){
				obj[ typeof (arr[i]) + arr[i] ] = true;
				newArr.push(arr[i]);
			}

		}
		return newArr;
		
	}
	console.log(getArrUnique3(arr));  //[1,2,3,"1"]

```
# FF & IE 
说出3条以上ff(firefox)和ie的脚本兼容问题
1.event

IE下是window.event,FF下的event只能在事件发生的现场使用，Firefox必须从源处添加参数传递，IE忽略这个参数。解决方法：event=event||window.event;

2.鼠标源事件

iE下event有x,y属性，firefox下没有，firefox有pageX，pageY属性，解决方法:mx=event.pageX?event.pageX:event.x;

3.事件源问题

IE下event对象有srcElement属性，但是没有target属性，Firefox下有target属性，但是没有srcElement属性，解决方法同上

4.绑定事件

IE下是 element.attachEvent (“onclick”,function);event.detachEvent(“onclick”,function);Firefox下是

element.addEventListener(“click”,function,true);element.removeEventListener(“click”,function,true);

5.阻止冒泡事件

preventDefault和stopPropagation在IE下无效，IE下是cancelBubble,retrun false在IE和FF下都有效

6.滤镜问题

IE下是filter.alpha.opacity,firefox下是style.opacity

7.父节点获取：

IE中支持使用parentElement和parentNode获取父节点。而Firefox只可以使用parentNode。 

解决方法：因为firefox与IE都支持DOM，因此统一使用parentNode来访问父节点。

# 截取字符串abcdefg的efg
```js
	str = "hello world";

	var slice = str.slice(3,7)  // 第二个参数位置

	var substring = str.substring(3,7) // 第二个参数位置，同上slice方法

	var substr = str.substr(3,7) // 第二个参数个数

	console.log(slice); // "lo w" ，array也有这个方法，array最强大的方法splice，改变原数组

	console.log(str); // "hello world"  不改变原字符串

	console.log(substring); // "lo wd"

	console.log(substr); // "lo worl"
```

# 字符串出现最多的char
判断一个字符串中出现次数最多的字符，统计这个次数
```js
str = "abcaba";
	
	function getMost(str){
		var obj = {};
		for(var i=0; i<str.length; i++){

			if(!obj[str.charAt(i)]){
				obj[str.charAt(i)] = 1;
			}else{
				obj[str.charAt(i)] ++ ;
			}
		}
		var max = 0; // 字符出现最多的次数
		var index = ""; //出现次数最多的是哪个字符
		for(var j in obj){
			if(obj[j] > max ){
				max = obj[j];
				index = j; 
			}
		}
		var newObj = {
			maxvalue:index,
			maxnum:max
		}
		return newObj;
	}
	console.log(getMost(str).index);
  ```

# 语义化的HTML
请解释一下什么是语义化的HTML
内容使用特定标签，通过标签就能大概了解整体页面的布局分布

# load faster
请说出三种减低页面加载时间的方法
1、压缩css、js文件
2、合并js、css文件，减少http请求
3、外部js、css文件放在最底下
4、减少dom操作，尽可能用变量替代不必要的dom操作

# FOUC
什么是FOUC？你如何来避免FOUC？
由于css引入使用了@import 或者存在多个style标签以及css文件在页面底部引入使得css文件加载在html之后导致页面闪烁、花屏
用link加载css文件，放在head标签里面

# AJAX
请尽可能详尽的解释AJAX的工作原理
创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）
判断数据传输方式(GET/POST)
打开链接 open()
发送 send()
当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数

# readonly & disable
form中的input可以设置为readonly和disable，请问2者有什么区别？
readonly不可编辑，但可以选择和复制；值可以传递到后台
disabled不能编辑，不能复制，不能选择；值不可以传递到后台

# WEB标准
WEB标准以及W3C标准是什么?
标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离。

# 行内元素
行内元素有哪些?块级元素有哪些?
行内元素: a b img em br i span input select
块级元素：div p h1-h6 form ul dl ol table

# 哪些css属性可以继承?
可继承： font-size font-family color, ul li dl dd dt;(字体属性和列表属性)
不可继承 ：border padding margin width height ;

# css优先级算法如何计算?
!important > id > class > 标签
!important 比 内联优先级高

# 前端页面由哪三层构成
前端页面由哪三层构成，分别是什么?作用是什么?
结构层 Html(页面结构内容，骨架) 表示层 CSS(网页的样式和外观) 行为层 js(实现网页的交互，动画效果)

# 清除浮动的几种方式，各自的优缺点
1.使用空标签清除浮动clear:both(缺点，增加无意义的标签)
2.使用overflow:auto(使用zoom:1用于兼容IE)或：overflow:hidden;
3.是用afert伪元素清除浮动(用于非IE浏览器)
```css
.Clearfix:after{ 
  content:””; 
  display:block; 
  height:0; 
  overflow:hidden; 
  clear:both;
} 
.clearfix{
   zoom:1;
}
```

# isArray
js如何判断一个对象是不是Array
```js
//方法1
function isArray(obj){
		return Object.prototype.toString.call(obj) === "[object Array]"
	}
	arr = "12";
	console.log(isArray(arr));
//方法2
Array.isArray(arr);
```

# clone
实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制
```js
function clone(obj){
		var o;
		switch(typeof obj) {
			case "undefined":
				break;
			case "string":
				o = obj + "";
				break;
			case "number":
				o = obj - 0;
				break;
			case "boolean":
				o = obj;
				break;
			case "object":
				if(obj === null){
					o = null;
				}else if(obj instanceof Array){
					o = [];
					for(var i = 0; i < obj.length; i++){
						o.push(obj[i]);
					}
				}else{
					o = {};
					for(var k in obj){
						o[k] = clone(obj[k]);
					}
				}
				break;
			default :
				o = obj;
				break;

		}
		return o;
	}
	var s = {fd:"df",fde:{we:3}};
	console.log(clone(s));
  ```

# 继承的使用
```js
function Animal(name){
		this.name = name;
		this.colors = ["red","blue","green"];
		this.showName = function(){
			return this.name;
		}
	}
	//第一种继承，原型链
	function Pig(){

	}
	Pig.prototype = new Animal();  //继承所有属性和方法，引起引用类型的原型属性会被所有实例共享
	
	var pig1 = new Pig();
	pig1.colors.push("black");
	console.log(pig1.colors); // ["red", "blue", "green", "black"]

	var pig2 = new Pig();
	console.log(pig2.colors);  // ["red", "blue", "green", "black"]
	

	//第二种继承，借用构造函数
	function Cat(myname){
		Animal.call(this,"Tom"); // call不能继承对象原型上的方法
	}
	var cat = new Cat();
	console.log(cat.name);  // Tom
	console.log(cat.showName()); //Tom

	function Dog(name,colors){
		Animal.apply(this,arguments) ;  //同上call
		//Animal.apply(this,[nam,colors]) ;
	}
	var dog = new Dog("fuwa");  // uwa
	console.log(dog.name);

	
	//第三种，组合继承
	function Super(name){
		this.name = name;
		this.colors = ["red","blue","green"];
	}
	Super.prototype.sayName = function(){
		console.log(this.name);
	}
	function Sub(myname,age){
		//继承属性
		Super.call(this,myname);
		this.age = age;
	}

	//继承方法
	Sub.prototype = new Super();
	Sub.prototype.constructor = Sub;
	Sub.prototype.sayAge = function(){
		console.log(this.age);
	}

	var sub1 = new Sub("peng",23);
	sub1.colors.push("black");  // ["red", "blue", "green", "black"]
	console.log(sub1.colors);
	sub1.sayName();
	sub1.sayAge();

	var sub2 = new Sub("youyi",50);
	console.log(sub2.colors);  // ["red", "blue", "green"]
	sub2.sayName();
	sub2.sayAge();
```

# 闭包（closure）
什么是闭包（closure），为什么要用它？
闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。

闭包的特性：

1.函数内再嵌套函数
2.内部函数可以引用外层的参数和变量
3.参数和变量不会被垃圾回收机制回收
```html
<ul id="demo">
		<li> index = 1</li>
		<li> index = 2</li>
		<li> index = 3</li>
		<li> index = 4</li>
		<li> index = 5</li>
	</ul>
	<script type="text/javascript">
window.onload = function(){
	var ulEle = document.getElementById("demo");
	var liEle = ulEle.getElementsByTagName("li");
	var len = liEle.length;
	for (var i=0 ;i < len ; i++){
		liEle[i].onclick = (function(num){
			return function(){
				alert(num)
			}
		})(i)
	}
}
	
	</script>
```

#  跨浏览器事件处理event
```js
function addEvent(elem, type, handler){
	　　if(elem.addEventListener){
	　　　　elem.addEventListener(type, handler, false);
	　　}else if(elem.attachEvent){
	           elem.attachEvent('on' + type, handler);
	　　}else{
	　　     elem['on' + type] = handler;
	      }
	}
```

# this
```js
var User = {
	  count: 1,
	 
	  getCount: function() {
	    return this.count;
	  }
	};
	 
	console.log(User.getCount());  // 1
	 
	var func = User.getCount;
	console.log(func());  // undefined
```

# 优雅降级 graceful degradation
什么叫优雅降级和渐进增强？
渐进增强 progressive enhancement： 
针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 
优雅降级 graceful degradation： 
一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 
区别： 
a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给 
b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要 
c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带















# 更多-more
+ [https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers](https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers)
+ [https://leohxj.gitbooks.io/front-end-database/content/interview/interview-exercises-with-JavaScript.html](https://leohxj.gitbooks.io/front-end-database/content/interview/interview-exercises-with-JavaScript.html)
















































