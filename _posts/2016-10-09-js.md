---
layout: post
title: js面试题及答案
tags:
- Interview
categories: JS
description: js面试题及答案
---

# js面试题及答案

knowledge points
{% highlight html linenos %}
HTML&CSS：
    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
    HTML5、CSS3、Flexbox

JavaScript：
    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

其他：
    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力
{% endhighlight %}

# js基本数据类型

- 介绍js的基本数据类型。

Undefined、Null、Boolean、Number、String、

ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )

# js内置对象

- 介绍js有哪些内置对象？

Object 是 JavaScript 中所有对象的父对象

数据封装类对象：Object、Array、Boolean、Number 和 String

其他对象：Function、Arguments、Math、Date、RegExp、Error

[了解 JavaScript 中的内置对象](http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html)

# Js standard

- 说几条写JavaScript的基本规范？

1. 不要在同一行声明多个变量。

2. 请使用 ===/!==来比较true/false或者数值

3. 使用对象字面量替代new Array这种形式

4. 不要使用全局函数。

5. Switch语句必须带有default分支

6. 函数不应该有时候有返回值，有时候没有返回值。

7. For循环必须使用大括号

8. If语句必须使用大括号

9. for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。

[编写高质量JavaScript代码的68个有效方法](https://www.cnblogs.com/luohaoran/p/6031437.html)

编写高质量代码-改善JavaScript程序的188个建议

# js原型

- JavaScript原型，原型链 ? 有什么特点？

每个对象都会在其内部初始化一个属性，就是`prototype(原型)`，

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的`原型链`的概念。

关系：

所有的引用类型（数组、对象、函数）， \_\_proto\_\_ 属性值指向它的构造函数的 “prototype” 属性值

instance.constructor.prototype = instance.\_\_proto\_\_

特点：

JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。

[js中的prototype和\_\_proto\_\_](http://pengyouyi.site/js/2017/03/01/js-prototype)


# stack-heap

- JavaScript有几种类型的值？，你能画一下他们的内存图吗？

栈：原始数据类型（Undefined，Null，Boolean，Number、String）

堆：引用数据类型（对象、数组和函数）

两种类型的区别是：存储位置不同；

原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；

引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

![http://www.w3school.com.cn/i/ct_js_value.gif](http://www.w3school.com.cn/i/ct_js_value.gif)

# parseFloat

- 如何将字符串转化为数字，例如’12.3b’?

parseFloat('12.3b'); // 12.3

# qian-fen-wei

- 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?

```js
	function myNum(num) {
      var xs = num.toString().split('.')[1]; // 判断是否有小数部分
      if (xs) {
      	return num && num
	        .toString()
	        .replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
	            return $2 + ',';
	        });
      }
      return num.toString().replace(/(\d{1,3})(?=(\d{3})+$)/g,'$1,');
	}

	console.log(myNum(num));
```

```js
	function comdify(num) {
		var re=/\d{1,3}(?=(\d{3})+$)/g;
		var n1=num.toString().replace(/^(\d+)((\.\d+)?)$/,function(s,s1,s2){return s1.replace(re,"$&,")+s2;});

		return n1;
	}
	console.log(comdify(num));
```

```js
var num = 12345678.90;

function turnQFW(num) { 
	var str = parseInt(num).toString();
	var zsLength = parseInt(num).toString().length;
	var xs = num.toString().split(".")[1];

	var iNum = str.length%3; //余数 
	var prev = ''; 
	var arr = []; 
	var iNow = 0; 
	var tmp = ''; 

	if (iNum !=0) { 
		prev = str.substring(0,iNum); //将余数截取出来 
		arr.push(prev); 
	} 
    // 剩下规则的3个数为一组，str长度为0、3、6、9、3n
    str = str.substring(iNum); 

    for (var i=0;i<str.length;i++) { 
		iNow++; 
		tmp +=str[i]; 
		if(iNow ==3 && tmp) { 
			arr.push(tmp); 
			tmp = ''; 
			iNow = 0; 
	    } 
    } 
    // 把整数部分变成千分位格式
    var zsStr = arr.join(',');
    
    if (zsLength <= 3) {
      return num;
	} else {
	   // 如果存在小数位
		if (xs) { 
			return zsStr + '.' + xs ;
		}
		return zsStr; 
	}
} 

console.log(turnQFW(num));
```

[为整数添加千分位-正则方法](https://blog.csdn.net/xuyunfei_2012/article/details/54628981)

[利用JS实现为数字添加千分位的操作](https://blog.csdn.net/krenyelang/article/details/6895755)

[为整数添加千分位](http://www.jb51.net/article/89799.htm)

[为浮点数添加、移除千分位](https://blog.csdn.net/u013558749/article/details/79422903)

# Random-ordering

- 如何实现数组的随机排序？

方法一：
```js
var arr = [1,2,3,4,5,6,7,8,9,10];
function randSort1(arr){
	for(var i = 0,len = arr.length;i < len; i++ ){
		var rand = parseInt(Math.random()*len);
		var temp = arr[rand];
		arr[rand] = arr[i];
		arr[i] = temp;
	}
	return arr;
}
console.log(randSort1(arr));
```
方法二：
```js
var arr = [1,2,3,4,5,6,7,8,9,10];
function randSort2(arr){
	var mixedArray = [];
	while(arr.length > 0){
		var randomIndex = parseInt(Math.random()*arr.length);
		mixedArray.push(arr[randomIndex]);
		arr.splice(randomIndex, 1);
	}
	return mixedArray;
}
console.log(randSort2(arr));
```
方法三：
```js
var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(function(){
	return Math.random() - 0.5;
})
console.log(arr);
```

# chain-scope

- Javascript作用链域?

全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。

当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。

# window-document

- 什么是window对象? 什么是document对象?

window对象是指浏览器打开的窗口。

document对象是Documentd对象（HTML 文档对象）的一个只读引用，

document对象是window对象的一个属性。window.document

# [“1”, “2”, “3”].map(parseInt)

- [“1”, “2”, “3”].map(parseInt) 答案是多少？

parseInt(string, radix)函数可解析一个字符串，并返回一个radix进制的整数。

【radix该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;

相当于解以下题：
```js
parseInt('1',0); // 1
parseInt('2',1); // NaN
parseInt('3',2); // NaN
```

[为什么 ["1", "2", "3"].map(parseInt) 返回 [1,NaN,NaN]？](http://blog.csdn.net/justjavac/article/details/19473199)

# use-strict

- javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？

use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,

**严格模式影响范围**

- 变量：  var、delete、变量关键字

- 对象： 只读属性、 对象字面量属性重复申明

- 函数：参数重名、arguments对象、申明

- 其他：this、eval、关键字...

**变量：**

不允许使用未声明的变量

不允许意外创建的全局变量

不允许删除变量、对象、函数

变量名不能使用 "arguments" 字符串 、"eval" 字符串、未来保留关键字

**对象：**

不允许对只读属性赋值 Object.defineProperty

不允许变量、函数参数、对象属性重名

**函数：**

不允许修改函数内的arguments对象的成员的值

无法在语句或块中声明函数

**其他：**

不允许使用八进制

不允许使用“with”语句

不允许使用arguments.callee

禁止this关键字指向全局对象。使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。

eval() 创建的变量不能在此函数外部被调用


**设立"严格模式"的目的**

主要有以下几个：错误检测、规范、效率、安全、面向未来

- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;

- 消除代码运行的一些不安全之处，保证代码运行的安全；

- 提高编译器效率，增加运行速度；

- 为未来新版本的Javascript做好铺垫。

[](https://msdn.microsoft.com/zh-cn/library/br230269(v=vs.94).aspx)

[JavaScript 严格模式(use strict)](http://www.runoob.com/js/js-strict.html)

[JS中的“use strict” 严格模式](https://www.cnblogs.com/liaojie970/p/7154144.html)

# instanceof

- 如何判断一个对象是否属于某个类？

JavaScript中判断一个对象 是否为一个类的实例主要有两种方法，即instanceof和constructor，前者的用法是：

`result = object instanceof class`

返回一个boolean值，指出对象是否为特定类的一个实例。后者的用法是：

`object.constructor`

表示创建对象的函数

```js
var a = [1, 2, 3];
￼alert(a instanceof Array);  //返回true
￼alert(a instanceof Object);  //返回true
￼
￼alert(a.constructor == Array);  //返回true
￼alert(a.constructor == Object);  //返回false
```

constructor更加精确地指向对象所属的类，

instanceof即使是父类也会返回true。

# new

- new操作符具体干了什么呢?

1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。

2、属性和方法被加入到 this 引用的对象中。

3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

# hasOwnProperty

- Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？

hasOwnProperty

javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。

使用方法：

`object.hasOwnProperty(proName)`

其中参数object是必选项。一个对象的实例。
proName是必选项。一个属性名称的字符串值。

如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。

# put-script-bottom

-把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？

1. 脚本会阻塞页面渲染，直到它们全部下载并执行完成后，页面的渲染才会继续；

2. 浏览器允许`并行下载`js文件，但是js下载过程仍然会阻塞其后面其他资源的下载,比如图片。

把脚本放在顶部会导致明显的延迟，通常表现为空白页面，用户无法浏览内容，也无法与页面进行交互。

脚本引起的问题是它们阻塞了并行下载。HTTP1.1规范建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下。

[JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制](https://blog.csdn.net/u012251421/article/details/50536265)

# js-defer

- js延迟加载的方式有哪些？

- defer和async

- 动态创建DOM方式（用得最多）

- 使用jQuery的getScript()方法

- 使用setTimeout延迟方法

- 让JS最后加载

- 按需异步载入js

**延迟的脚本：defer和async**

HTML4 为 \<script> 标签扩展的属性 defer，IE4+和FireFox3.5+ 的浏览器支持。

```html
<script type='text/javascript' src='' defer></script>
```

HTML5引入async

```html
<script async src="script.js"></script>
```

defer和async的区别：async是加载完成后自动执行，而defer需要等待页面完成后执行。

**动态创建DOM方式：**

```js
var element = document.createElement("script");  
element.src = "defer.js";  
document.getElementByTagName('head')[0].appendChild(element);
// document.body.appendChild(element);
```

**使用jQuery的getScript()方法:**

```js
$.getScript("outer.js",function(){//回调函数，成功获取文件后执行的函数  
      console.log("脚本加载完成")  
}); 
```

**使用setTimeout延迟方法：**

```js
<script type="text/javascript" >
    function A(){
        $.post("/lord/login",{name:username,pwd:password},function(){
            alert("Hello");
        });
    }
    $(function (){
        setTimeout('A()', 1000); //延迟1秒
    })
</script>
```

[JS延迟加载的几种方式](https://blog.csdn.net/meijory/article/details/76389762)

# 手写AJAX

- Ajax 是什么? 如何创建一个Ajax？

ajax的全称：Asynchronous Javascript And XML。

异步传输+js+xml。

所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。

(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息

(3)设置响应HTTP请求状态变化的函数

(4)发送HTTP请求

(5)获取异步调用返回的数据

(6)使用JavaScript和DOM实现局部刷新

```js
var xhr = new XMLHttpRequest();

xhr.open('GET', '/api', true);

xhr.onreadystatechange = function() {
	if (xhr.readyState === 4) {
		if (xhr.status === 200) {
			alert(xhr.responseText)
		}
	}
}

xhr.send(null);
```

readyState

- 0 - (未初始化) 还没有调用send()方法

- 1 - (载入) 已调用send()方法，正在发送请求

- 2 - (载入完成) send() 方法执行完成，已接收到全部响应内容

- 3 - (交互) 正在解析响应内容

- 4 - (完成) 响应内容解析完成，可以在客户端调用了

status

- 2XX - 表示成功处理请求。比如 200

- 3XX - 需要重定向，浏览器直接跳转

- 4XX - 客户端请求错误，比如 404

- 5XX - 服务器端错误

第三个参数：

- true 表示异步,就是不等待,直接返回，异步获取数据！

- false 表示同步,等待有返回数据的时候再继续往下走，还没有得到数据的时候就会卡在那里，直到获取数据为止。

# Ajax-cache

- Ajax 解决浏览器缓存问题？

1. 在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。

2. 在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。

3. 在URL后面加上一个随机数： "fresh=" + Math.random();。

4. 在URL后面加上时间搓："nowtime=" + new Date().getTime();。

5. 如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。

# synchronize-async

- 同步和异步的区别?

同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。

异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。

# Cross-domain

- 如何解决跨域问题?

jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面

[同源策略及限制](http://pengyouyi.site/http/2017/11/07/http-Communication)

# AMD-CMD

- AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？

Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。

区别：

1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
 
2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

```js
// CMD
define(function(require, exports, module) {
    var a = require('./a')
    a.doSomething()
    // 此处略去 100 行
    var b = require('./b') // 依赖可以就近书写
    b.doSomething()
    // ...
})
```
```js
// AMD 默认推荐
define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
    a.doSomething()
    // 此处略去 100 行
    b.doSomething()
    // ...
})
```

[requirejs初学](http://pengyouyi.site/js/2016/09/29/requirejs)

[seajs初学](http://pengyouyi.site/js/2016/09/30/seajs)

[requirejs和seajs的区别](http://pengyouyi.site/js/2016/10/03/requirejs&&seajs)

[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)

[CMD](https://github.com/seajs/seajs/issues/242)

# documen.write-innerHTML

- documen.write和 innerHTML的区别

document.write只能重绘整个页面

innerHTML可以重绘页面的一部分

# DOM

- DOM操作——怎样添加、移除、移动、复制、创建和查找节点?

（1）创建新节点

```js
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点
```
（2）添加、移除、替换、插入

```js
appendChild()
removeChild()
replaceChild()
insertBefore() //在已有的子节点前插入一个新的子节点
```
（3）查找

```js
getElementsByTagName()    //通过标签名称
getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementById()    //通过元素Id，唯一性
getElementByClassName()
```

# window-node

- 如何判断当前脚本运行在浏览器还是node环境中？

this === window ? 'browser' : 'node';

通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中

# 字节length

- 编写一个方法求一个字符串的字节长度

```js
//方法1
function GetBytes(str){
  var len = str.length;
  var bytes = len;
  for(var i = 0;i<len;i++){
    if(str.charCodeAt(i)>255){
      bytes++;
    }
  }
  return bytes;
}
var s ="j你";
console.log(GetBytes(s));  //中文字占2个字节 

//方法2
function getLeng(str){
  if(!arguments.length || !str){
    return null;
  }
  var len = str.length;
  var newlen = 0;
  for(var i=0; i<len; i++){
    if(str.charCodeAt(i)>255){
      newlen+=2;
    }else{
      newlen++;
    }
  }
  return newlen;
}

var s =" ";
console.log(getLeng(s));
```
# 如何控制alert中的换行
```js
alert("hello \n world")
```

# 解释em
```js
document.getElementById("ElementID").style.fontSize="1.5em" 
```
em是个相对单位。

# 按照格式showTime 
xxxx年xx月xx日xx时xx分xx秒动态显示时间 要求不足10的补0 
```js
<div id="demo"></div>
<script type="text/javascript">

	function f(str){
		return str>9? str :"0"+ str
	}

	function getTime(){
		var time = new Date();
		
		var year = time.getFullYear();
		var month = f(time.getMonth()+1);
		var day = f(time.getDate());
		var hour = f(time.getHours());
		var minutes = f(time.getMinutes());
		var second = f(time.getSeconds());

		var mytime = year+ "-" + month + "-" + day + " " + hour +":"+ minutes + ":" +second;
		return mytime;

	}

	function intext(){
		document.getElementById("demo").innerHTML = getTime()
	}
	setInterval(intext,1000);
</script>
```

# 数组unique
编写一个方法 去掉一个数组的重复元素 
```js
var arr = [ 1,2,3,"1"];
	//方法1
	function getArrUnique(arr){
		var newArr = [ ];
		for (var i=0; i < arr.length;i++){

			if(newArr.indexOf(arr[i]) == -1)
				newArr.push(arr[i]);	
		}
		return newArr;
	}
	
	function getArrUnique2(arr){
		var newArr = [];
		var obj ={};
		for(var i=0;i<arr.length;i++){
			if(!obj[arr[i]]){
				obj[arr[i]] = true;
				newArr.push(arr[i]);
			}

		}
		return newArr;  
		
	}
	console.log(getArrUnique2(arr));  //[1,2,3]  error result

	//改进以上方法
	//方法2
	function getArrUnique3(arr){
		var newArr = [];
		var obj ={};
		for(var i=0;i<arr.length;i++){
			if(!obj[ typeof (arr[i]) + arr[i] ]){
				obj[ typeof (arr[i]) + arr[i] ] = true;
				newArr.push(arr[i]);
			}

		}
		return newArr;
		
	}
	console.log(getArrUnique3(arr));  //[1,2,3,"1"]

```
# FF & IE 
说出3条以上ff(firefox)和ie的脚本兼容问题  
**1.event**

IE下是window.event,FF下的event只能在事件发生的现场使用，Firefox必须从源处添加参数传递，IE忽略这个参数。  
解决方法：`event=event||window.event;`

**2.鼠标源事件**

iE下event有x,y属性，firefox下没有，firefox有pageX，pageY属性，解决方法:mx=event.pageX?event.pageX:event.x;

**3.事件源问题**

IE下event对象有srcElement属性，但是没有target属性，Firefox下有target属性，但是没有srcElement属性，解决方法同上

**4.绑定事件**

IE下是 element.attachEvent (“onclick”,function);event.detachEvent(“onclick”,function);Firefox下是

element.addEventListener(“click”,function,true);element.removeEventListener(“click”,function,true);

**5.阻止冒泡事件**

preventDefault和stopPropagation在IE下无效，IE下是cancelBubble,retrun false在IE和FF下都有效

**6.滤镜问题**

IE下是filter.alpha.opacity,firefox下是style.opacity

**7.父节点获取：**

IE中支持使用parentElement和parentNode获取父节点。而Firefox只可以使用parentNode。 

解决方法：因为firefox与IE都支持DOM，因此统一使用parentNode来访问父节点。

# 截取字符串abcdefg的efg
```js
str = "hello world";

var slice = str.slice(3,7)  // 第二个参数位置

var substring = str.substring(3,7) // 第二个参数位置，同上slice方法

var substr = str.substr(3,7) // 第二个参数个数

console.log(slice); // "lo w" ，array也有这个方法，array最强大的方法splice，改变原数组

console.log(str); // "hello world"  不改变原字符串

console.log(substring); // "lo w"

console.log(substr); // "lo worl"
```

# 字符串出现最多的char
判断一个字符串中出现次数最多的字符，统计这个次数
```js
str = "abcaba";
	
function getMost(str){
	var obj = {};
	for(var i=0; i<str.length; i++){

		if(!obj[str.charAt(i)]){
			obj[str.charAt(i)] = 1;
		}else{
			obj[str.charAt(i)] ++ ;
		}
	}
	var max = 0; // 字符出现最多的次数
	var index = ""; //出现次数最多的是哪个字符
	for(var j in obj){
		if(obj[j] > max ){
			max = obj[j];
			index = j; 
		}
	}
	var newObj = {
		maxvalue:index,
		maxnum:max
	}
	return newObj;
}
console.log(getMost(str).index);
```

# 语义化的HTML
请解释一下什么是语义化的HTML
内容使用特定标签，通过标签就能大概了解整体页面的布局分布

# load faster
请说出三种减低页面加载时间的方法

1、压缩css、js文件  
2、合并js、css文件，减少http请求  
3、外部js、css文件放在最底下  
4、减少dom操作，尽可能用变量替代不必要的dom操作  

# FOUC
什么是FOUC？你如何来避免FOUC？

由于css引入使用了@import 或者存在多个style标签以及css文件在页面底部引入使得css文件加载在html之后导致页面闪烁、花屏
用link加载css文件，放在head标签里面

# AJAX
请尽可能详尽的解释AJAX的工作原理

创建ajax对象（XMLHttpRequest/ActiveXObject(Microsoft.XMLHttp)）  
判断数据传输方式(GET/POST)  
打开链接 open()  
发送 send()  
当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数

# readonly & disable
form中的input可以设置为readonly和disable，请问2者有什么区别？

readonly不可编辑，但可以选择和复制；值可以传递到后台  
disabled不能编辑，不能复制，不能选择；值不可以传递到后台

# WEB标准
WEB标准以及W3C标准是什么?

标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离。

# 行内元素
行内元素有哪些?块级元素有哪些?

行内元素: a b img em br i span input select  
块级元素：div p h1-h6 form ul dl ol table

# 哪些css属性可以继承?
可继承： font-size font-family color, ul li dl dd dt;(字体属性和列表属性)  
不可继承 ：border padding margin width height ;

# css优先级算法如何计算?
!important > id > class > 标签  
!important 比 内联优先级高

# 前端页面由哪三层构成
前端页面由哪三层构成，分别是什么?作用是什么?  
结构层 Html(页面结构内容，骨架) 表示层 CSS(网页的样式和外观) 行为层 js(实现网页的交互，动画效果)

# 清除浮动的几种方式，各自的优缺点
1.使用空标签清除浮动clear:both(缺点，增加无意义的标签)  
2.使用overflow:auto(使用zoom:1用于兼容IE)或：overflow:hidden;  
3.是用afert伪元素清除浮动(用于非IE浏览器)  

```css
.Clearfix:after{ 
  content:””; 
  display:block; 
  height:0; 
  overflow:hidden; 
  clear:both;
} 
.clearfix{
   zoom:1;
}
```

# isArray
js如何判断一个对象是不是Array
```js
//方法1
function isArray(obj){
		return Object.prototype.toString.call(obj) === "[object Array]"
	}
	arr = "12";
	console.log(isArray(arr));
//方法2
Array.isArray(arr);
```

# clone
实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制
```js
function clone(obj){
	var o;
	switch(typeof obj) {
		case "undefined":
			break;
		case "string":
			o = obj + "";
			break;
		case "number":
			o = obj - 0;
			break;
		case "boolean":
			o = obj;
			break;
		case "object":
			if(obj === null){
				o = null;
			}else if(obj instanceof Array){
				o = [];
				for(var i = 0; i < obj.length; i++){
					o.push(obj[i]);
				}
			}else{
				o = {};
				for(var k in obj){
					o[k] = clone(obj[k]);
				}
			}
			break;
		default :
			o = obj;
			break;

	}
	return o;
}
var s = {fd:"df",fde:{we:3}};
console.log(clone(s));
```

# 继承的使用-inherit
```js
function Animal(name){
	this.name = name;
	this.colors = ["red","blue","green"];
	this.showName = function(){
		return this.name;
	}
}
//第一种继承，原型链
function Pig(){

}
Pig.prototype = new Animal();  //继承所有属性和方法，引起引用类型的原型属性会被所有实例共享

var pig1 = new Pig();
pig1.colors.push("black");
console.log(pig1.colors); // ["red", "blue", "green", "black"]

var pig2 = new Pig();
console.log(pig2.colors);  // ["red", "blue", "green", "black"]


//第二种继承，借用构造函数
function Cat(myname){
	Animal.call(this,"Tom"); // call不能继承对象原型上的方法
}
var cat = new Cat();
console.log(cat.name);  // Tom
console.log(cat.showName()); //Tom

function Dog(name,colors){
	Animal.apply(this,arguments) ;  //同上call
	//Animal.apply(this,[nam,colors]) ;
}
var dog = new Dog("fuwa");  // uwa
console.log(dog.name);
	
//第三种，组合继承
function Super(name){
	this.name = name;
	this.colors = ["red","blue","green"];
}
Super.prototype.sayName = function(){
	console.log(this.name);
}
function Sub(myname,age){
	//继承属性
	Super.call(this,myname);
	this.age = age;
}

//继承方法
Sub.prototype = new Super();
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function(){
	console.log(this.age);
}

var sub1 = new Sub("peng",23);
sub1.colors.push("black");  // ["red", "blue", "green", "black"]
console.log(sub1.colors);
sub1.sayName();
sub1.sayAge();

var sub2 = new Sub("youyi",50);
console.log(sub2.colors);  // ["red", "blue", "green"]
sub2.sayName();
sub2.sayAge();
```

[构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)

[非构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html)

# 闭包（closure）
什么是闭包（closure），为什么要用它？

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。

闭包的特性：

1.函数内再嵌套函数  
2.内部函数可以引用外层的参数和变量  
3.参数和变量不会被垃圾回收机制回收  
{% highlight html linenos %}
<ul id="demo">
	<li> index = 1</li>
	<li> index = 2</li>
	<li> index = 3</li>
	<li> index = 4</li>
	<li> index = 5</li>
</ul>
<script type="text/javascript">
window.onload = function(){
	var ulEle = document.getElementById("demo");
	var liEle = ulEle.getElementsByTagName("li");
	var len = liEle.length;
	for (var i=0 ;i < len ; i++){
		liEle[i].onclick = (function(num){
			return function(){
				alert(num)
			}
		})(i)
	}
}
	
</script>
{% endhighlight %}

# scope-hoisting

- 解释JavaScript中的作用域与变量声明提升？

变量作用域分为局部作用域和全局作用域。

**局部变量（处于函数级别的作用域）**

javascript没有块级作用域（被花括号包围的）；当是，javascript有拥有函数级别的作用域，也就是说，在一个函数内定义的变量只能在函数内部访问或者这个函数内部的函数访问

局部变量优先级大于全局变量

setTimeout中的函数是在全局作用域中执行的

**变量提升（Variable Hoisting）**

所以的变量声明都会提升到函数的开头（如果这个变量在这个函数里面）或者全局作用域的开头（如果这个变量是一个全局变量）。

**函数声明会覆盖变量声明**

如果存在函数声明和变量声明（注意：仅仅是声明，还没有被赋值），而且变量名跟函数名是相同的，那么，它们都会被提示到外部作用域的开头，但是，函数的优先级更高，所以变量的值会被函数覆盖掉。

但是，如果这个变量或者函数其中是赋值了的，那么另外一个将无法覆盖它

[javascript中的变量作用域以及变量提升](https://www.cnblogs.com/MockingBirdHome/p/3385152.html)

[javascript变量声明 及作用域](https://www.cnblogs.com/silentjesse/p/4024536.html)

# this
```js
var User = {
  count: 1,
 
  getCount: function() {
    return this.count;
  }
};
 
console.log(User.getCount());  // 1
 
var func = User.getCount;
console.log(func());  // undefined
```

* this总是指向函数的直接调用者（而非间接调用者）；

* 如果有new关键字，this指向new出来的那个对象；

* 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；

[js中的this](http://pengyouyi.site/js/2016/11/30/js-this)

# navigator.userAgent

- 检测浏览器版本版本有哪些方式？

使用navigator.userAgent的值来判断。userAgent是JavaScript的内置对象navigator的属性。

[JS 获得浏览器类型和版本](https://segmentfault.com/a/1190000007640795)

# 优雅降级 graceful degradation
什么叫优雅降级和渐进增强？

渐进增强 progressive enhancement：   
针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 

优雅降级 graceful degradation：   
一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。   
区别： 

a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给   
b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要   
c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带  
  

# create object
- javascript创建对象的几种方式？

1、对象字面量的方式   
```js
person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
```
2、用function来模拟无参的构造函数
```js
function Person(){}
var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
person.name="Mark";
person.age="25";
person.work=function(){
    alert(person.name+" hello...");
}
person.work();
```
3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）
```js
function Pet(name,age,hobby){
    this.name=name;//this作用域：当前对象
    this.age=age;
    this.hobby=hobby;
    this.eat=function(){
        alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
    }
}
var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
maidou.eat();//调用eat方法
```
4、用工厂方式来创建（内置对象）
```js
var wcDog =new Object();
wcDog.name="旺财";
wcDog.age=3;
wcDog.work=function(){
    alert("我是"+wcDog.name+",汪汪汪......");
}
wcDog.work();
```
5、用原型方式来创建
```js
function Dog(){

}
Dog.prototype.name="旺财";
Dog.prototype.eat=function(){
    alert(this.name+"是个吃货");
}
var wangcai =new Dog();
wangcai.eat();
```

6、用混合方式来创建
```js
function Car(name,price){
    this.name=name;
    this.price=price; 
}
Car.prototype.sell=function(){
    alert("我是"+this.name+"，我现在卖"+this.price+"万元");
}
var camry =new Car("凯美瑞",27);
camry.sell(); 
```


# null & undefined
- null，undefined 的区别？

null        表示一个对象是“没有值”的值，也就是值为“空”；  

undefined   表示一个变量没有被声明，不存在这个值，或者被声明了但没有被赋值；

undefined不是一个有效的JSON，而null是；  
undefined的类型(typeof)是undefined；  
null的类型(typeof)是object；


Javascript将未赋值的变量默认值设为undefined；  
Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。

typeof undefined  
    //"undefined"  
    undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；   
    例如变量被声明了，但没有赋值时，就等于undefined  

typeof null  
    //"object"  
    null : 是一个对象(空对象, 没有任何属性和方法)；  
    例如作为函数的参数，表示该函数的参数不是对象；  

注意：  
    在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined  
    null == undefined // true  
    null === undefined // false  

[js的null，undefined或undeclared的区别](http://pengyouyi.site/js/2017/03/02/js-null-undefined)

# ev.stopPropagation()

- 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？

1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。

2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；

3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）


# 跨浏览器事件处理event

- 写一个通用的事件侦听器函数

```js
function addEvent(elem, type, handler){
　　if(elem.addEventListener){
　　　　elem.addEventListener(type, handler, false);
　　}else if(elem.attachEvent){
           elem.attachEvent('on' + type, handler);
　　}else{
　　     elem['on' + type] = handler;
      }
}
```

```js
// event(事件)工具集，来源：github.com/markyun
    markyun.Event = {
        // 页面加载完成后
        readyEvent : function(fn) {
            if (fn==null) {
                fn=document;
            }
            var oldonload = window.onload;
            if (typeof window.onload != 'function') {
                window.onload = fn;
            } else {
                window.onload = function() {
                    oldonload();
                    fn();
                };
            }
        },
        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
        // 参数： 操作的元素,事件名称 ,事件处理程序
        addEvent : function(element, type, handler) {
            if (element.addEventListener) {
                //事件类型、需要执行的函数、是否捕捉
                element.addEventListener(type, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent('on' + type, function() {
                    handler.call(element);
                });
            } else {
                element['on' + type] = handler;
            }
        },
        // 移除事件
        removeEvent : function(element, type, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(type, handler, false);
            } else if (element.datachEvent) {
                element.detachEvent('on' + type, handler);
            } else {
                element['on' + type] = null;
            }
        },
        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
        stopPropagation : function(ev) {
            if (ev.stopPropagation) {
                ev.stopPropagation();
            } else {
                ev.cancelBubble = true;
            }
        },
        // 取消事件的默认行为
        preventDefault : function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        // 获取事件目标
        getTarget : function(event) {
            return event.target || event.srcElement;
        },
        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
        getEvent : function(e) {
            var ev = e || window.event;
            if (!ev) {
                var c = this.getEvent.caller;
                while (c) {
                    ev = c.arguments[0];
                    if (ev && Event == ev.constructor) {
                        break;
                    }
                    c = c.caller;
                }
            }
            return ev;
        }
    };
```

# eval

- eval是做什么的？

它的功能是把对应的字符串解析成JS代码并运行；

应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。

由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');

# JSON
- JSON 的了解

JSON字符串转换为JSON对象:

{% highlight js linenos %}
var obj = eval('('+ str +')');
var obj = str.parseJSON();
var obj = JSON.parse(str);
{% endhighlight %}

JSON对象转换为JSON字符串：

{% highlight js linenos %}
var last = obj.toJSONString();
var last = JSON.stringify(obj);
{% endhighlight %}


# 更多-more
+ [https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers](https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers)
+ [https://leohxj.gitbooks.io/front-end-database/content/interview/interview-exercises-with-JavaScript.html](https://leohxj.gitbooks.io/front-end-database/content/interview/interview-exercises-with-JavaScript.html)
















































